import { Link } from '@nextui-org/react'

import { CollapsibleBlock } from '../../collapsible-block.tsx'

<CodeWithAccoridions>
## !!accordions Section 1: What are generics in TypeScript?

Generics are a TypeScript feature that allows developers to write reusable and flexible code while maintaining strict 
type safety. By enabling types to be passed as parameters, they help create structures and functions that adapt to the 
specific type of data they operate on, without losing the benefits of TypeScriptâ€™s static typing.

Generics appear in TypeScript code inside angle brackets, in the format `<T>`, where T represents a passed-in type. 
`<T>` can be read as a generic of type T. In this case, T will operate in the same way that parameters work in functions, 
as placeholders for a type that will be declared when an instance of the structure is created.

1. Passing type argument to `type`, `interface`, `class`
  - Type aliases can use generics to create flexible and reusable types.
```ts
type ApiResponse<T> = {
//                ^?
    data: T;
    status: number;
    error?: string;
};

// Usage
type User = { id: number; name: string };
const userResponse: ApiResponse<User> = {
    data: { id: 1, name: "Alice" },
    status: 200,
};

type Company = { id: number; name: string; address: string };
const companyResponse: ApiResponse<Company> = {
    data: { id: 1, name: "Alice", address: "Saigon, Vietnam" },
    status: 200,
};
```

  - Interfaces can also take generic parameters, enabling more specific and reusable contracts.
```ts
interface KeyValuePair<K, V> {
    key: K;
    value: V;
}

// Usage
const stringPair: KeyValuePair<string, string> = { key: "name", value: "Alice" };
const numberPair: KeyValuePair<number, boolean> = { key: 42, value: true };
```

  - Classes can take generic types to define properties and methods with flexible type handling.
```ts
class MyStorage<T> {
    private items: T[] = [];

    addItem(item: T): void {
        this.items.push(item);
    }

    getAllItems(): T[] {
        return this.items;
    }
}

// Usage
const stringStorage = new MyStorage<string>();
stringStorage.addItem("Hello");
stringStorage.addItem("World");

const numberStorage = new MyStorage<number>();
numberStorage.addItem(42);
numberStorage.addItem(100);
```

2. Passing type argument to `function`
Functions can accept generic parameters to work with varying types dynamically.

```ts
function createSet<T>() {
  return new Set<T>();
};

const stringSet = createSet<string>();
//      ^?


// Generic syntax for arrow functions
const createSetWithInitialValue = <T>(initialValue: T) => {
  return new Set<T>([initialValue]);
};

// Notice that in this case we didnâ€™t have to explicitly pass the type in the angle brackets (<>)
// This behaviour is called "type argument inference", the TS compiler just looked at the value "initialValue", and set Type to its type.
const numberSet = createSetWithInitialValue(14);
//      ^?
```

You can also write generic React functional components

```tsx
type DropdownProps<T> = {
    items: T[];
    getLabel: (item: T) => string;
    onSelect: (item: T) => void;
};

function Dropdown<T>({ items, getLabel, onSelect }: DropdownProps<T>) {
    return (
        <select onChange={(e) => onSelect(items[Number(e.target.value)])}>
            {items.map((item, index) => (
                <option key={index} value={index}>
                    {getLabel(item)}
                </option>
            ))}
        </select>
    );
}


// Usage
type Product = {
  id: number;
  name: string;
}
const ProductDropdown = () => {
    const products: Product[] = [
        { id: 1, name: "Laptop" },
        { id: 2, name: "Phone" },
    ];

    return (
        <Dropdown
            items={products}
            getLabel={(product) => product.name}
            onSelect={(product) => console.log("Selected:", product)}
        />
    );
};
```

## !!accordions Section 2: Why Do We Need Generics?
Letâ€™s look at a practical scenario and explore how TypeScript without generics, and TypeScript with generics handle it.

Scenario: `filterByKey` Function
Imagine you need to filter an array of objects by a specific key-value pair.

Here's our first approach
```ts
// #1 Approach

type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

function filterByKey(array, key, value) {
    return array.filter((item) => item[key] === value);
}

const result = filterByKey(users, "name", "Alice");
//      ^?

const result2 = filterByKey(users, "address", "Saigon");
const firstItem = result2[0]

```

So with the first apprach, the code may look fine at first but it's actually bad
    - ðŸš« The return type is any, losing the structure of the objects.
    - ðŸš« No compile-time error validation
    - ðŸš« No type-checking or IntelliSense

Now we go to the second approach
```ts
// #2 Approach

// @errors: 2345 2339 564 18048
type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

function filterByKey(array: User[], key: keyof User, value: unknown) {
    return array.filter((item) => item[key] === value);
}

const filteredUsers = filterByKey(users, "name", "Alice");
// âœ… The return type is User[]
// âœ… Has compile-time validation for "key"

const filteredUsers2 = filterByKey(users, "test", "Alice"); // âœ… Error checking for "key" parameter type

// ------------------------------------------------------------------------------------------------------------ //

type Application = {
  id: string;
  title: string;
}
const apps: Application[] = [
    { id: "gfrlj-ukhn", title: "Settings" },
    { id: "oiudxs-rte", title: "Photos" },
];

const filteredApps = filterByKey(apps, "title", "Settings");

```

With the second apprach, the code is fully typed, much safer and better but it's still not good enough
  - Improvements:
    - âœ… The return type is `User[]`
    - âœ… Compile-time error validation
    - âœ… Type-checking or IntelliSense works as expected

  - Problems:
    - ðŸš« The code is not reusable and flexible enough, we can't use `filterByKey` for a other data structure


So what we really need here is to write reusable and flexible code while maintaining strict type safety, that's when generics shine:

```ts
// #3 Approach

type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

type Application = {
  id: string;
  title: string;
}
const apps: Application[] = [
    { id: "gfrlj-ukhn", title: "Settings" },
    { id: "oiudxs-rte", title: "Photos" },
];

function filterByKey<T>(array: T[], key: keyof T, value: unknown) {
    return array.filter((item) => item[key] === value);
}

const filteredUsers = filterByKey(users, "name", "Alice");
//     ^?

const filteredApps = filterByKey(apps, "title", "Settings");
//     ^?

```

Why Generics Are a Game-Changer:

- âœ… Reusability: Write once, use everywhere. Generics adapt to any type you provide.
- âœ… Type Safety: Prevent invalid inputs and incorrect usage at compile time.
- âœ… Scalability: Your code can handle future data changes or new use cases with minimal updates.
- âœ… Developer Productivity: Autocomplete and type inference save time and reduce redundant load.

## !!accordions Section 3: Some Techniques You Need for Writing Good Generic TypeScript Code
Writing efficient and maintainable generic TypeScript code requires a solid grasp of its capabilities and best practices. Here are essential techniques to master:
1. Define Generic Constraints:
  - Type Safety: Ensures the generic type meets certain requirements, avoiding runtime errors.
  - Flexibility: Generic constraints provide reusable, strongly-typed utilities.
  - Clarity: Clearly communicates the expected structure of the input to other developers.

When working with APIs, you can constrain a generic type to represent the available endpoints and their return types.
```ts
// @errors: 2345
type APIEndpoints = {
    "/users": { id: number; name: string }[];
    "/posts": { id: number; title: string; content: string }[];
};

function fetchData<T extends keyof APIEndpoints>(endpoint: T): Promise<APIEndpoints[T]> {
    return fetch(endpoint).then((res) => res.json());
}

// Usage
fetchData("/users").then((users) => console.log(users[0].name)); // âœ… Valid
fetchData("/posts").then((posts) => console.log(posts[0].title)); // âœ… Valid

fetchData("/comments");
```
When working with APIs, you can use generics to enforce type constraints for responses, ensuring that only objects with specific properties are accepted.
```ts
// @errors: 2345
interface ApiResponse<T> {
    data: T;
    success: boolean;
}

// Constraint: T must have an `id` property
function validateApiResponse<T extends { id: number }>(response: ApiResponse<T>): boolean {
    return response.success && response.data.id > 0;
}

// Usage
const userResponse = {
    data: { id: 1, name: "Alice" },
    success: true,
};
console.log(validateApiResponse(userResponse)); // âœ… Valid

const invalidResponse = {
    data: { name: "Bob" },
    success: false,
};

console.log(validateApiResponse(invalidResponse));

```
</CodeWithAccoridions>
