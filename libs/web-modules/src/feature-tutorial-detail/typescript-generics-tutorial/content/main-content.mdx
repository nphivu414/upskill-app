import { Link } from '@nextui-org/react'

import { CollapsibleBlock } from '../../collapsible-block.tsx'

<CodeWithAccoridions>
## !!accordions Section 1: What are generics in TypeScript?

Generics are a TypeScript feature that allows developers to write reusable and flexible code while maintaining strict 
type safety. By enabling types to be passed as parameters, they help create structures and functions that adapt to the 
specific type of data they operate on, without losing the benefits of TypeScriptâ€™s static typing.

Generics appear in TypeScript code inside angle brackets, in the format `<T>`, where T represents a passed-in type. 
`<T>` can be read as a generic of type T. In this case, T will operate in the same way that parameters work in functions, 
as placeholders for a type that will be declared when an instance of the structure is created.

1. Passing type argument to `type`, `interface`, `class`
  - Type aliases can use generics to create flexible and reusable types.
```ts
type ApiResponse<T> = {
//                ^?
    data: T;
    status: number;
    error?: string;
};

// Usage
type User = { id: number; name: string };
const userResponse: ApiResponse<User> = {
    data: { id: 1, name: "Alice" },
    status: 200,
};

type Company = { id: number; name: string; address: string };
const companyResponse: ApiResponse<Company> = {
    data: { id: 1, name: "Alice", address: "Saigon, Vietnam" },
    status: 200,
};
```

  - Interfaces can also take generic parameters, enabling more specific and reusable contracts.
```ts
interface KeyValuePair<K, V> {
    key: K;
    value: V;
}

// Usage
const stringPair: KeyValuePair<string, string> = { key: "name", value: "Alice" };
const numberPair: KeyValuePair<number, boolean> = { key: 42, value: true };
```

  - Classes can take generic types to define properties and methods with flexible type handling.
```ts
class MyStorage<T> {
    private items: T[] = [];

    addItem(item: T): void {
        this.items.push(item);
    }

    getAllItems(): T[] {
        return this.items;
    }
}

// Usage
const stringStorage = new MyStorage<string>();
stringStorage.addItem("Hello");
stringStorage.addItem("World");

const numberStorage = new MyStorage<number>();
numberStorage.addItem(42);
numberStorage.addItem(100);
```

2. Passing type argument to `function`
Functions can accept generic parameters to work with varying types dynamically.

```ts
function createSet<T>() {
  return new Set<T>();
};

const stringSet = createSet<string>();
//      ^?


// Generic syntax for arrow functions
const createSetWithInitialValue = <T>(initialValue: T) => {
  return new Set<T>([initialValue]);
};

// Notice that in this case we didnâ€™t have to explicitly pass the type in the angle brackets (<>)
// This behaviour is called "type argument inference", the TS compiler just looked at the value "initialValue", and set Type to its type.
const numberSet = createSetWithInitialValue(14);
//      ^?
```

You can also write generic React functional components

```tsx
type DropdownProps<T> = {
    items: T[];
    getLabel: (item: T) => string;
    onSelect: (item: T) => void;
};

function Dropdown<T>({ items, getLabel, onSelect }: DropdownProps<T>) {
    return (
        <select onChange={(e) => onSelect(items[Number(e.target.value)])}>
            {items.map((item, index) => (
                <option key={index} value={index}>
                    {getLabel(item)}
                </option>
            ))}
        </select>
    );
}


// Usage
type Product = {
  id: number;
  name: string;
}
const ProductDropdown = () => {
    const products: Product[] = [
        { id: 1, name: "Laptop" },
        { id: 2, name: "Phone" },
    ];

    return (
        <Dropdown
            items={products}
            getLabel={(product) => product.name}
            onSelect={(product) => console.log("Selected:", product)}
        />
    );
};
```

## !!accordions Section 2: Why Do We Need Generics?
Letâ€™s look at a practical scenario and explore how TypeScript without generics, and TypeScript with generics handle it.

Scenario: `filterByKey` Function
Imagine you need to filter an array of objects by a specific key-value pair.

Here's our first approach
```ts
// #1 Approach

type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

function filterByKey(array, key, value) {
    return array.filter((item) => item[key] === value);
}

const result = filterByKey(users, "name", "Alice");
//      ^?

const result2 = filterByKey(users, "address", "Saigon");
const firstItem = result2[0]

```

So with the first apprach, the code may look fine at first but it's actually bad
    - ðŸš« The return type is any, losing the structure of the objects.
    - ðŸš« No compile-time error validation
    - ðŸš« No type-checking or IntelliSense

Now we go to the second approach
```ts
// #2 Approach

// @errors: 2345 2339 564 18048
type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

function filterByKey(array: User[], key: keyof User, value: unknown) {
    return array.filter((item) => item[key] === value);
}

const filteredUsers = filterByKey(users, "name", "Alice");
// âœ… The return type is User[]
// âœ… Has compile-time validation for "key"

const filteredUsers2 = filterByKey(users, "test", "Alice"); // âœ… Error checking for "key" parameter type

// ------------------------------------------------------------------------------------------------------------ //

type Application = {
  id: string;
  title: string;
}
const apps: Application[] = [
    { id: "gfrlj-ukhn", title: "Settings" },
    { id: "oiudxs-rte", title: "Photos" },
];

const filteredApps = filterByKey(apps, "title", "Settings");

```

With the second apprach, the code is fully typed, much safer and better but it's still not good enough
  - Improvements:
    - âœ… The return type is `User[]`
    - âœ… Compile-time error validation
    - âœ… Type-checking or IntelliSense works as expected

  - Problems:
    - ðŸš« The code is not reusable and flexible enough, we can't use `filterByKey` for a other data structure


So what we really need here is to write reusable and flexible code while maintaining strict type safety, that's when generics shine:

```ts
// #3 Approach

type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

type Application = {
  id: string;
  title: string;
}
const apps: Application[] = [
    { id: "gfrlj-ukhn", title: "Settings" },
    { id: "oiudxs-rte", title: "Photos" },
];

function filterByKey<T>(array: T[], key: keyof T, value: unknown) {
    return array.filter((item) => item[key] === value);
}

const filteredUsers = filterByKey(users, "name", "Alice");
//     ^?

const filteredApps = filterByKey(apps, "title", "Settings");
//     ^?

```

Why Generics Are a Game-Changer:

- âœ… Reusability: Write once, use everywhere. Generics adapt to any type you provide.
- âœ… Type Safety: Prevent invalid inputs and incorrect usage at compile time.
- âœ… Scalability: Your code can handle future data changes or new use cases with minimal updates.
- âœ… Developer Productivity: Autocomplete and type inference save time and reduce redundant load.

## !!accordions Section 3: Some Techniques You Need for Writing Good Generic TypeScript Code
Writing efficient and maintainable generic TypeScript code requires a solid grasp of its capabilities and best practices. Here are essential techniques to master:

**1. Leverage `extends` to Add Type Constraints**
    - Use `extends` to specify the shape or properties a generic type must follow to.
```ts
// @errors: 2345
interface User {
    id: number;
    name: string;
}

function printUserName<T extends User>(user: T): void {
    console.log(user.name);
}

printUserName({ id: 1, name: "Alice" }); // âœ… Valid

printUserName({ id: 1, name: "Vu", age: 30 }); // âœ… Valid

printUserName({ id: 2 });

```

**2. Use `keyof` to Constrain Keys**
    - When working with object keys, use `keyof` to ensure generic parameters align with valid keys.

```ts
// @errors: 2345

interface User { id: number; name: string }
interface Post { id: number; title: string; content: string }

type APIEndpoints = {
    "/users": User[];
    "/posts": Post[];
};

function fetchData<T extends keyof APIEndpoints>(endpoint: T): Promise<APIEndpoints[T]> {
    return fetch(endpoint).then((res) => res.json());
}

// Usage
fetchData("/users").then((users) => console.log(users[0].name)); // âœ… Valid
fetchData("/posts").then((posts) => console.log(posts[0].title)); // âœ… Valid

fetchData("/comments");

```

**3. Use default Generic Parameters**
    - Provide defaults for generic types to make your API easier to use.
```ts
interface Response<T = string> {
    data: T;
    status: number;
}

const response: Response = { data: "Success", status: 200 }; // Uses default `string`
const typedResponse: Response<number> = { data: 42, status: 200 };

```

**4. Use Conditional Types for Flexible Constraints**
    - Conditional types allow enforcing rules that vary based on the provided type.
```ts
type ExtractArrayType<T> = T extends (infer U)[] ? U : never;

type StringArrayType = ExtractArrayType<string[]>; // string
type NonArrayType = ExtractArrayType<number>; // never

```

**5. Combine Generics with Discriminated Unions**
    - Use discriminated unions to simplify handling multiple types within a generic context.
```ts
// @errors: 2353
type Shape = 
    | { type: "circle"; radius: number }
    | { type: "square"; side: number }
    | { type: "unknown" };

function calculateArea<T extends Shape>(shape: T): number {
    if (shape.type === "circle") {
        return Math.PI * shape.radius ** 2;
    } else if (shape.type === "square") {
        return shape.side ** 2;
    }
    return 0;
}

console.log(calculateArea({ type: "circle", radius: 5 })); // âœ… 78.54
console.log(calculateArea({ type: "square", side: 2 })); // âœ… 4
console.log(calculateArea({ type: "unknown" })); // âœ… 0

console.log(calculateArea({ type: "square", radius: 4 }));

```

**6. Layer Generics for Complex Scenarios**
    - Use multiple generics when handling relationships between types.
```ts
function mapObject<T, U>(obj: Record<string, T>, transform: (value: T) => U): Record<string, U> {
    const result: Record<string, U> = {};
    for (const key in obj) {
        result[key] = transform(obj[key]);
    }
    return result;
}

const input = { a: 1, b: 2 };
const output = mapObject(input, (x) => x * 2); // { a: 2, b: 4 }

```

**7. Combine Generics with Overloads**
    - For functions with varied behaviors, use overloads to improve clarity.
```ts
function processInput<T extends string>(input: T): string;
function processInput<T extends number>(input: T): number;
function processInput(input: unknown): unknown {
    if (typeof input === "string") {
        return input.toUpperCase();
    } else if (typeof input === "number") {
        return input * 2;
    }
    return input;
}

console.log(processInput("hello")); // HELLO
console.log(processInput(42));      // 84

```

**8. Creating Mapped Types with Generics**
    - When working with TypeScript, there are times when you will need to create a type that should have the same shape as another type
```ts
type BooleanFields<T> = {
  [K in keyof T]: boolean;
};

type User = {
  email: string;
  name: string;
}

type UserFetchOptions = BooleanFields<User>;
//          ^?
```

**9. Compose with Utility Types**
    - TypeScript provides utility types (e.g., `Partial`, `Pick`, `Omit`) to extend generics without redefining functionality.
```ts
function updateObject<T>(obj: T, updates: Partial<T>): T {
    return { ...obj, ...updates };
}

const user = { id: 1, name: "Alice" };
const updated = updateObject(user, { name: "Bob" });
//       ^?
```
</CodeWithAccoridions>
