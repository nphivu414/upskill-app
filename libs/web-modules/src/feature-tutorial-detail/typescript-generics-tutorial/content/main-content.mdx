import { Link } from '@heroui/react'

import { CollapsibleBlock } from '../../collapsible-block.tsx'

<CodeWithAccoridions>
## !!accordions Section 1: What are generics in TypeScript?

Generics are a TypeScript feature that allows developers to write reusable and flexible code while maintaining strict 
type safety. By enabling types to be passed as parameters, they help create structures and functions that adapt to the 
specific type of data they operate on, without losing the benefits of TypeScriptâ€™s static typing.

Generics appear in TypeScript code inside angle brackets, in the format `<T>`, where T represents a passed-in type. 
`<T>` can be read as a generic of type T. In this case, T will operate in the same way that parameters work in functions, 
as placeholders for a type that will be declared when an instance of the structure is created.

**1. Passing type parameter to `type`, `interface`, `class`**

Type aliases can use generics to create flexible and reusable types.
```ts
type ApiResponse<T> = {
//                ^?
    data: T;
    status: number;
    error?: string;
};

// Usage
type User = { id: number; name: string };
const userResponse: ApiResponse<User> = {
    data: { id: 1, name: "Alice" },
    status: 200,
};

type Company = { id: number; name: string; address: string };
const companyResponse: ApiResponse<Company> = {
    data: { id: 1, name: "Alice", address: "Saigon, Vietnam" },
    status: 200,
};
```

Interfaces can also take generic parameters, enabling more specific and reusable contracts.
```ts
interface KeyValuePair<K, V> {
    key: K;
    value: V;
}

// Usage
const stringPair: KeyValuePair<string, string> = { key: "name", value: "Alice" };
const numberPair: KeyValuePair<number, boolean> = { key: 42, value: true };
```

Classes can take generic types to define properties and methods with flexible type handling.
```ts
class MyStorage<T> {
    private items: T[] = [];

    addItem(item: T): void {
        this.items.push(item);
    }

    getAllItems(): T[] {
        return this.items;
    }
}

// Usage
const stringStorage = new MyStorage<string>();
stringStorage.addItem("Hello");
stringStorage.addItem("World");

const numberStorage = new MyStorage<number>();
numberStorage.addItem(42);
numberStorage.addItem(100);
```

**2. Passing type parameter to `function`**

Functions can accept generic parameters to work with varying types dynamically.
```ts
function createSet<T>() {
  return new Set<T>();
};

const stringSet = createSet<string>();
//      ^?


// Generic syntax for arrow functions
const createSetWithInitialValue = <T>(initialValue: T) => {
  return new Set<T>([initialValue]);
};

// Notice that in this case we didnâ€™t have to explicitly pass the type in the angle brackets (<>)
// This behaviour is called "type parameter inference", the TS compiler just looked at the value "initialValue", and set Type to its type.
const numberSet = createSetWithInitialValue(14);
//      ^?
```

**3. Passing type parameter to React components**

React components can also accept generic parameters to define the type of props they receive.
```tsx
type DropdownProps<T> = {
    items: T[];
    getLabel: (item: T) => string;
    onSelect: (item: T) => void;
};

function Dropdown<T>({ items, getLabel, onSelect }: DropdownProps<T>) {
    return (
        <select onChange={(e) => onSelect(items[Number(e.target.value)])}>
            {items.map((item, index) => (
                <option key={index} value={index}>
                    {getLabel(item)}
                </option>
            ))}
        </select>
    );
}


// Usage
type Product = {
  id: number;
  name: string;
}
const ProductDropdown = () => {
    const products: Product[] = [
        { id: 1, name: "Laptop" },
        { id: 2, name: "Phone" },
    ];

    return (
        <Dropdown
            items={products}
            getLabel={(product) => product.name}
            onSelect={(product) => console.log("Selected:", product)}
        />
    );
};
```

## !!accordions Section 2: Why Do We Need Generics?
Letâ€™s look at a practical scenario and explore how TypeScript without generics, and TypeScript with generics handle it.

Scenario: `filterByKey` Function
Imagine you need to filter an array of objects by a specific key-value pair.

Here's our first approach
```ts
// #1 Approach

type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

function filterByKey(array, key, value) {
    return array.filter((item) => item[key] === value);
}

const result = filterByKey(users, "name", "Alice");
//      ^?

const result2 = filterByKey(users, "address", "Saigon");
const firstItem = result2[0]

```

So with the first apprach, the code may look fine at first but it's actually bad
    - ðŸš« The return type is any, losing the structure of the objects.
    - ðŸš« No compile-time error validation
    - ðŸš« No type-checking or IntelliSense

Now we go to the second approach
```ts
// #2 Approach

// @errors: 2345 2339 564 18048
type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

function filterByKey(array: User[], key: keyof User, value: unknown) {
    return array.filter((item) => item[key] === value);
}

const filteredUsers = filterByKey(users, "name", "Alice");
// âœ… The return type is User[]
// âœ… Has compile-time validation for "key"

const filteredUsers2 = filterByKey(users, "test", "Alice"); // âœ… Error checking for "key" parameter type

// ------------------------------------------------------------------------------------------------------------ //

type Application = {
  id: string;
  title: string;
}
const apps: Application[] = [
    { id: "gfrlj-ukhn", title: "Settings" },
    { id: "oiudxs-rte", title: "Photos" },
];

const filteredApps = filterByKey(apps, "title", "Settings");

```

With the second apprach, the code is fully typed, much safer and better but it's still not good enough
  - Improvements:
    - âœ… The return type is `User[]`
    - âœ… Compile-time error validation
    - âœ… Type-checking or IntelliSense works as expected

  - Problems:
    - ðŸš« The code is not reusable and flexible enough, we can't use `filterByKey` for a other data structure


So what we really need here is to write reusable and flexible code while maintaining strict type safety, that's when generics shine:

```ts
// #3 Approach

type User = {
  id: number;
  name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
];

type Application = {
  id: string;
  title: string;
}
const apps: Application[] = [
    { id: "gfrlj-ukhn", title: "Settings" },
    { id: "oiudxs-rte", title: "Photos" },
];

function filterByKey<T>(array: T[], key: keyof T, value: unknown) {
    return array.filter((item) => item[key] === value);
}

const filteredUsers = filterByKey(users, "name", "Alice");
//     ^?

const filteredApps = filterByKey(apps, "title", "Settings");
//     ^?

```

**Key Takeaways:**

- âœ… Reusability: Write once, use everywhere. Generics adapt to any type you provide.
- âœ… Type Safety: Prevent invalid inputs and incorrect usage at compile time.
- âœ… Scalability: Your code can handle future data changes or new use cases with minimal updates.
- âœ… Developer Productivity: Autocomplete and type inference save time and reduce redundant load.

## !!accordions Section 3: Generic Parameter Defaults
Generic parameter defaults allow developers to specify a fallback type for generic parameters when they are not explicitly provided. 
This feature simplifies APIs and makes code more user-friendly, reducing the need for repetitive type annotations while maintaining flexibility for advanced use cases.

Here are some common scenarios where default generic parameters can help us write more concise and flexible code:

**1. In a file-upload system, you might deal with metadata that varies depending on the type of file.**
```ts
interface FileMetadata<T = {}> {
    filename: string;
    size: number;
    metadata: T; // metadata info is flexible and not always required.
}

// Set metadata as empty object for all common files
const commonFile: FileMetadata = {
    filename: "image.png",
    size: 12345,
    metadata: {},
};

// Set PDF metadata for PDF file 
type PdfMetadata = { version: string, pages: number, resolution: string }
const pdfFile: FileMetadata<PdfMetadata> = {
    filename: "image.png",
    size: 12345,
    metadata: {
        version: '1.0.0',
        pages: 5,
        resolution: '594 x 841'
    },
};

```
The generic parameter `T` in the `FileMetadata` interface has a default value of `{}` (an empty object). This allows the metadata property to be flexible and not always required to have a specific structure.
The `commonFile` object uses the default empty object for metadata, while the `pdfFile` object specifies a more specific `PdfMetadata` type for the metadata property.


**2. Another common pattern is fetching data from an API. Default generics will simplify the function interface for typical use cases.**
```ts
type FetchOptions = {
    headers?: Record<string, string>;
    method?: "GET" | "POST" | "PUT" | "DELETE";
    body?: string;
};

type FetchResult<T, E> = {
    data?: T;
    error?: E;
};

async function fetchData<T = unknown, E = Error>(
    url: string,
    options?: FetchOptions
): Promise<FetchResult<T, E>> {
    try {
        const response = await fetch(url, {
            headers: {
                "Content-Type": "application/json",
                ...(options?.headers || {}),
            },
            method: options?.method || "GET",
            body: options?.body,
        });

        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody.message || "Something went wrong");
        }

        const data: T = await response.json();
        return { data };
    } catch (error) {
        return { error: error as E };
    }
}

// Basic Usage with Defaults
(async () => {
    const result = await fetchData("https://api.example.com/users");

    const data = result.data
//         ^?

    const error = result.error
//         ^?

    if (data) {
        console.log("Fetched data:", data);
    } else {
        console.error("Error:", error);
    }
})();


// Custom Data and Error Type
interface User {
    id: number;
    name: string;
}

interface ApiError {
    statusCode: number;
    message: string;
}

(async () => {
    const result = await fetchData<User, ApiError>("https://api.example.com/users");
    const data = result.data
//         ^?

    const error = result.error
//         ^?

    if (data) {
        console.log("Fetched user:", data);
    } else {
        console.error("Error Code:", error?.statusCode);
        console.error("Message:", error?.message);
    }
})();

```

**Key Takeaways:**
- âœ… Ease of Use: Default generics reduce verbosity and make APIs more approachable.
- âœ… Common Defaults: Defaults should represent the most commonly used type, streamlining development.
- âœ… Override Flexibility: While defaults simplify usage, they still allow for explicit overrides when needed.

## !!accordions Section 4: Generic Constraints
Generic constraints are a way to limit the types that can be used as parameters in generics. 
This ensures that the provided types adhere to specific rules or structures, enhancing type safety and enabling more predictable 
functionality. For example, constraints can be used to restrict the types passed into a function. 

Below are some examples demonstrating how this can be done:

**1. Use `extends` to Add Type Constraints**

The function `printUserName` is defined with a generic type parameter `T`.
The constraint `T` extends `User` ensures that `T` must be a type that includes at least the properties defined in the `User` interface.
This means that `T` can be `User` or any other type that has at least the `id` and `name` properties.
```ts
// @errors: 2345
interface User {
    id: number;
    name: string;
}

function printUserName<T extends User>(user: T): void {
    console.log(user.name);
//               ^?
}

printUserName({ id: 1, name: "Alice" }); // âœ… Valid

printUserName({ id: 1, name: "Vu", age: 30 }); // âœ… Valid

printUserName({ id: 2 }); // ðŸš« Invalid parameter

```
The first call is valid because the object `{ id: 1, name: "Alice" }` matches the `User` interface.

The second call is also valid because the object `{ id: 1, name: "Vu", age: 30 }` includes the required `id` and `name` properties, even though it has an additional age property.

The third call is invalid because the object `{ id: 2 }` does not include the `name` property, which is required by the `User` interface.

**2. Use `keyof` to Constrain Keys**

The class `KeyValueStore` is defined with two generic type parameters, `T` and `K`.

The constraint `K extends keyof T` ensures that the key type `K` must be a valid key of the object type `T`. 

This means that `K` can only be a key that exists in the object type `T`.

```ts
// @errors: 2345
class KeyValueStore<T extends object, K extends keyof T> {
    private store: Record<K, T[K]> = {} as Record<K, T[K]>;

    set(key: K, value: T[K]): void {
        this.store[key] = value;
    }

    get(key: K): T[K] | undefined {
        return this.store[key];
    }
}

// Usage
type User = {
    id: number;
    name: string;
    email: string;
};

const userStore = new KeyValueStore<User, "id" | "email">();
userStore.set("id", 123); // âœ… Valid
userStore.set("email", "test@example.com"); // âœ… Valid

console.log(userStore.get("id")); // âœ… 123

userStore.set("name", "John");

```

The first two calls to `set` are valid because the `KeyValueStore` instance is created with the `User` type and the keys `"id"` and `"email"`.

The call to `get` is also valid because the key `"id"` is part of the `User` type.

The last call to `set` is invalid because the key `"name"` is not part of the keys specified when creating the `KeyValueStore` instance.

**Key Takeaways:**
- âœ… Type Safety: Constraints ensure that only valid types are used in generics.
- âœ… Predictable Behavior: Constraints help prevent runtime errors by enforcing type rules at compile time.
- âœ… Enhanced Flexibility: Constraints allow for more specific and structured generic usage.

## !!accordions Section 5: Conditional types with generics
Conditional types allow us to conditionally choose the right type based on a condition we define; 
we can take this one step further, however, and pair them with generics to allow us to write more reusable code. 

**1. Creating types that transform union types into more usable structures**

In this example, we define a conditional type `InterationEvent<T>` that transforms a union of event types into more specific event types. 
The conditional type checks if the type `T` is `"click"` or `"keypress"` and adds additional properties to the base event type accordingly.

```ts
// @errors: 2353
type BaseEvent = { type: string }

type InterationEvent<T> = T extends "click"
    ? BaseEvent & { x: number; y: number }
    : T extends "keypress"
    ? BaseEvent & { key: string }
    : never;

// Usage
type ClickEvent = InterationEvent<"click">;
type KeypressEvent = InterationEvent<"keypress">;

const click: ClickEvent = { type: "click", x: 100, y: 200 }; // âœ… Valid
const keypress: KeypressEvent = { type: "keypress", key: "Enter" }; // âœ… Valid

const invalidEvent: KeypressEvent = { type: "keypress", x: 50, y: 10 };

```
The first two assignments are valid because the `ClickEvent` and `KeypressEvent` types are correctly inferred based on the conditional type.

The last assignment is invalid because the `KeypressEvent` type does not include the `x` and `y` properties.

**2. Enforcing Proper Key-Value Relationships**

In this example, we define a conditional type `KeyValue<T>` that enforces a key-value relationship between the keys and values of an object.
The conditional type checks if the type `T` is an object and ensures that the keys and values are of the same type.
```ts
type Config<T extends Record<string, any>> = {
    [K in keyof T]: T[K] extends boolean ? boolean
        : T[K] extends Array<Record<string, any>> ? Array<Record<string, any>>
        : T[K] extends Array<any> ? Array<any>
        : string;
};

// Usage
// @errors: 2322
type AppConfig = Config<{
    darkMode: boolean;
    language: string;
    themes: string[];
    stores: Record<string, string>[];
}>;

const config: AppConfig = { // âœ… Correct type
    darkMode: true, 
    language: "en",
    themes: ["retro", "flat", "material"],
    stores: [{
        appstore: "https://apps.apple.com/us/charts/iphone",
        playstore: "https://play.google.com/store/apps"
    }]
};

const invalidConfig: AppConfig = {
    ...config,
    darkMode: "true", 
};

```
The `config` object is valid because it adheres to the `AppConfig` type, which enforces the correct key-value relationships.

The `invalidConfig` object is invalid because the `darkMode` key is assigned a string value instead of a boolean.

**Key Takeaways:**
- âœ… Enhanced Type Safety: Conditional types with generics allow for more precise type checking.
- âœ… Improved Reusability: Conditional types can be used to create reusable type transformations.
- âœ… Better Code Structure: Conditional types help enforce consistent data structures and relationships.

## !!accordions Section 6: Closing thoughts
Generics can be a really helpful tool when working with TypeScript and can help us write more reusable, flexible, and easier-to-maintain code. However, 
they do have an initial barrier to entry that might be difficult to overcome, but once you do, they open up a wide variety of possibilities and benefits in your code.

</CodeWithAccoridions>
